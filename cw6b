1.
-- wybieramy sobie raster i miejscowość nastepnie wyznaczamy część wspólną obiektów geometrycznych
CREATE TABLE juras.intersects AS  
SELECT a.rast, b.municipality 
FROM rasters.dem AS a, vectors.porto_parishes AS b  
WHERE ST_Intersects(a.rast, b.geom) AND b.municipality ilike 'porto'; 

2.
--dodanie klucza głównego
alter table juras.intersects add column rid SERIAL PRIMARY KEY;

3.
--utworzenie indeksu przestrzennego
--gist: Generalized Search Tree)-based index must be vector type
--można użyć do przyspieszenia wyszukiwania pełnotekstowego-wyszukiwanie ciągów znaków
--ST_onvexHull oblicza wypukły kadłub?? geometrii
CREATE INDEX idx_intersects_rast_gist ON juras.intersects USING gist (ST_ConvexHull(rast)); 

4.
--dodanie raster constraints
-- schema::name table_name::name raster_column::name 
--wprowadzamy ograniczenia na tabeli
SELECT AddRasterConstraints('juras'::name, 
'intersects'::name,'rast'::name); 

5.
--Obcinanie rastra na podstawie wektora. 
--Intersect: Zwraca zestaw par geometria-wartość piksela reprezentujących wspólną część 
--dwóch rastrów lub geometryczne przecięcie wektoryzacji rastra i geometrii.
CREATE TABLE juras.clip AS  
SELECT ST_Clip(a.rast, b.geom, true), b.municipality  
FROM rasters.dem AS a, vectors.porto_parishes AS b  
WHERE ST_Intersects(a.rast, b.geom) AND b.municipality like 'PORTO';

6.
--Połączenie wielu kafelków w jeden raster. 
CREATE TABLE juras.union AS  
SELECT ST_Union(ST_Clip(a.rast, b.geom, true)) 
FROM rasters.dem AS a, vectors.porto_parishes AS b 
WHERE b.municipality ilike 'porto' and ST_Intersects(b.geom,a.rast); 

7.
--rastrowanie wektoru
-- 8BUI: 8-bit unsigned integer
--dla braku danych mamy przypisana taka o wartość(na końcu)
CREATE TABLE juras.porto_parishes AS 
WITH r AS ( SELECT rast FROM rasters.dem LIMIT 1 ) 
SELECT ST_AsRaster(a.geom,r.rast,'8BUI',a.id,-32767) AS rast 
FROM vectors.porto_parishes AS a, r 
WHERE a.municipality ilike 'porto'; 

8.
--Łączy rekordy z poprzedniego przykładu przy użyciu funkcji ST_UNION w pojedynczy raster
 DROP TABLE juras.porto_parishes; --> drop table porto_parishes first CREATE TABLE schema_name.porto_parishes AS 
WITH r AS ( SELECT rast FROM rasters.dem LIMIT 1 ) 
SELECT st_union(ST_AsRaster(a.geom,r.rast,'8BUI',a.id,-32767)) AS rast FROM vectors.porto_parishes AS a, r 
WHERE a.municipality ilike 'porto'; 

9.
--Po uzyskaniu pojedynczego rastra można generować kafelki za pomocą funkcji ST_Tile
-- WITH AS: widoki o zaqsięgu instrukcji Nie są one przechowywane w schemacie bazy danych: 
--zamiast tego są ważne tylko w zapytaniu, do którego należą.
WITH r AS ( 
SELECT rast FROM rasters.dem 
LIMIT 1 ) 
SELECT st_tile(st_union(ST_AsRaster(a.geom,r.rast,'8BUI',a.id,-32767)),128,128,true,-32767) AS rast 
FROM vectors.porto_parishes AS a, r 
WHERE a.municipality ilike 'porto';

10.
--Konwertowanie rastrów na wektory
create table juras.intersection as 
SELECT a.rid,(ST_Intersection(b.geom,a.rast)).geom,(ST_Intersection(b.geom,a.rast) ).val
FROM rasters.landsat8 AS a, vectors.porto_parishes AS b
WHERE b.parish ilike 'paranhos' and ST_Intersects(b.geom,a.rast);

11.
--ST_DumpAsPolygons konwertuje rastry w wektory (poligony).
--val: wartość pasma pikseli
--Każdy poligon jest sumą wszystkich pikseli dla tego pasma, które mają tę samą wartość 
--piksela oznaczoną przez val.
CREATE TABLE juras.dumppolygons AS 
SELECT a.rid,(ST_DumpAsPolygons(ST_Clip(a.rast,b.geom))).geom,(ST_DumpAsPolygons(ST_Clip(a.rast,b.geom))).val
FROM rasters.landsat8 AS a, vectors.porto_parishes AS b
WHERE b.parish ilike 'paranhos' and ST_Intersects(b.geom,a.rast);

12.
--Funkcja ST_Band służy do wyodrębniania pasm z rastra 
--tu pytamy o czwarte pasmo
CREATE TABLE juras.landsat_nir AS 
SELECT rid, ST_Band(rast,4) AS rast 
FROM rasters.landsat8;

13.
--ST_Clip może być użyty do wycięcia rastra z innego rastra. Poniższy przykład 
--wycina jedną parafię z tabeli vectors.porto_parishes. Wynik będzie potrzebny do wykonania kolejnych przykładów. 
--crop=true?
CREATE TABLE juras.paranhos_dem AS 
SELECT a.rid,ST_Clip(a.rast, b.geom,true) as rast 
FROM rasters.dem AS a, vectors.porto_parishes AS b 
WHERE b.parish ilike 'paranhos' and ST_Intersects(b.geom,a.rast); 

14.
--Poniższy przykład użycia funkcji ST_Slope wygeneruje nachylenie przy użyciu 
--poprzednio wygenerowanej tabeli (wzniesienie). 
--32-bit float i okreslamy jednostki nachylenia
CREATE TABLE juras.paranhos_slope AS 
SELECT a.rid,ST_Slope(a.rast,1,'32BF','PERCENTAGE') as rast 
FROM juras.paranhos_dem AS a; 

15.
--Aby zreklasyfikować raster należy użyć funkcji ST_Reclass. 
CREATE TABLE juras.paranhos_slope_reclass AS 
SELECT a.rid,ST_Reclass(a.rast,1,']0-15]:1, (15-30]:2, (30-9999:3', '32BF',0) 
FROM juras.paranhos_slope AS a;

16.
--Aby obliczyć statystyki rastra można użyć funkcji ST_SummaryStats. Poniższy przykład wygeneruje 
--statystyki dla kafelka.
--Returns summarystats consisting of count, sum, mean, stddev, min, max 
--for a given raster band of a raster or raster coverage. If no band is specified nband defaults to 1.
SELECT st_summarystats(a.rast) AS stats 
FROM juras.paranhos_dem AS a; 

17.
--Przy użyciu UNION można wygenerować jedną statystykę wybranego rastra. 
SELECT st_summarystats(ST_Union(a.rast)) 
FROM juras.paranhos_dem AS a; 

18.
--ST_SummaryStats z lepszą kontrolą złożonego typu danych
WITH t AS ( SELECT st_summarystats(ST_Union(a.rast)) AS stats FROM juras.paranhos_dem AS a ) 
SELECT (stats).min,(stats).max,(stats).mean FROM t;

19.
--ST_SummaryStats w połączeniu z GROUP BY, aby wyświetlić statystykę dla każdego poligonu "parish" 
WITH t AS ( 
SELECT b.parish AS parish, st_summarystats(ST_Union(ST_Clip(a.rast, b.geom,true))) AS stats
FROM rasters.dem AS a, vectors.porto_parishes AS b 
WHERE b.municipality ilike 'porto' and ST_Intersects(b.geom,a.rast) group by b.parish) 
SELECT parish,(stats).min,(stats).max,(stats).mean FROM t; 

20.
--Funkcja ST_Value pozwala wyodrębnić wartość piksela z punktu lub zestawu punktów.
--Ponieważ geometria punktów jest wielopunktowa, a funkcja ST_Value wymaga geometrii jednopunktowej, 
--należy przekonwertować geometrię wielopunktową na geometrię jednopunktową za pomocą 
--funkcji (ST_Dump(b.geom)).geom. 
SELECT b.name,st_value(a.rast,(ST_Dump(b.geom)).geom) 
FROM  rasters.dem a, vectors.places AS b 
WHERE ST_Intersects(a.rast,b.geom) 
ORDER BY b.name;

21.
--TPI porównuje wysokość każdej komórki w DEM ze średnią wysokością określonego sąsiedztwa wokół tej komórki.
--Obecna wersja PostGIS może obliczyć TPI jednego piksela za pomocą sąsiedztwa wokół tylko jednej komórki
--rozdzielczosc 30 metrów 
create table juras.tpi30 as 
select ST_TPI(a.rast,1) as rast 
from rasters.dem a;

22.
--Poniższa kwerenda utworzy indeks przestrzenny
--Oblicza wypukły kadłub geometrii. Wypukły kadłub to najmniejsza wypukła geometria, która 
--obejmuje wszystkie geometrie na wejściu.
CREATE INDEX idx_tpi30_rast_gist ON juras.tpi30 
USING gist (ST_ConvexHull(rast)); 

23.
--Dodanie constraintów
SELECT AddRasterConstraints('juras'::name, 
'tpi30'::name,'rast'::name);

24.
--Problem do samodzielnego rozwiązania 
create table juras.tpi30_porto as 
SELECT ST_TPI(a.rast,1) as rast 
FROM rasters.dem AS a, vectors.porto_parishes AS b  
WHERE ST_Intersects(a.rast, b.geom) AND b.municipality ilike 'porto'

CREATE INDEX idx_tpi30_porto_rast_gist ON juras.tpi30_porto USING gist (ST_ConvexHull(rast)); 

SELECT AddRasterConstraints('juras'::name, 
'tpi30_porto'::name,'rast'::name); 

----------------- ALGEBRA MAP ---------------------------------
24.
--Poniższe przykłady pokazują jak stosując obie techniki utworzyć wartości NDVI na podstawie obrazu Landsat8. 
--Tworzy nowy jednopasmowy raster utworzony przez zastosowanie prawidłowej operacji algebraicznej PostgreSQL 
--na dwóch pasmach zdefiniowanych przez wyrażenie na dwóch wejściowych pasmach rastrowych 
--Wynikowy raster będzie miał zasięg zdefiniowany przez parametr extendtype.
CREATE TABLE juras.porto_ndvi AS 
WITH r AS ( SELECT a.rid,ST_Clip(a.rast, b.geom,true) AS rast 
FROM rasters.landsat8 AS a, vectors.porto_parishes AS b 
WHERE b.municipality ilike 'porto' and ST_Intersects(b.geom,a.rast))
SELECT r.rid, ST_MapAlgebra( r.rast, 1, r.rast, 4,'([rast2.val] - [rast1.val]) / ([rast2.val] +[rast1.val])::float','32BF' ) AS rast 
FROM r; 

25.
--Poniższe zapytanie utworzy indeks przestrzenny na wcześniej stworzonej tabeli: 
CREATE INDEX idx_porto_ndvi_rast_gist ON juras.porto_ndvi 
USING gist (ST_ConvexHull(rast)); 

26.
--Dodanie constraintów: 
SELECT AddRasterConstraints('juras'::name, 
'porto_ndvi'::name,'rast'::name);

27.
--Funkcja zwrotna 
--W pierwszym kroku należy utworzyć funkcję, które będzie wywołana później:
create or replace function juras.ndvi( value double precision [] [] [], pos integer [][], 
VARIADIC userargs text [] ) 
RETURNS double precision AS 
$$ 
BEGIN 
--RAISE NOTICE 'Pixel Value: %', value [1][1][1];-->For debug purposes 
RETURN (value [2][1][1] - value [1][1][1])/(value [2][1][1]+value [1][1][1]); --> NDVI calculation! 
END; 
$$ 
LANGUAGE 'plpgsql' IMMUTABLE COST 1000; 

28.
--W kwerendzie algebry map należy można wywołać zdefiniowaną wcześniej funkcję 
CREATE TABLE juras.porto_ndvi2 AS 
WITH r AS ( SELECT a.rid,ST_Clip(a.rast, b.geom,true) AS rast 
FROM rasters.landsat8 AS a, vectors.porto_parishes AS b 
WHERE b.municipality ilike 'porto' and ST_Intersects(b.geom,a.rast) )
SELECT 
	r.rid,ST_MapAlgebra(
	r.rast, ARRAY[1,4],
	'juras.ndvi(double precision[],
	integer[],text[])'::regprocedure, --> This is the function! 
	'32BF'::text ) AS rast FROM r; 
29.
--Dodanie indeksu przestrzennego: 
CREATE INDEX idx_porto_ndvi2_rast_gist ON juras.porto_ndvi2 USING gist (ST_ConvexHull(rast)); 

30.
--Dodanie constraintów: 
SELECT AddRasterConstraints('juras'::name, 
'porto_ndvi2'::name,'rast'::name);


---------- EKSPORT DANYCH -------------------
1.
--Funkcja ST_AsTiff tworzy dane wyjściowe jako binarną reprezentację pliku tiff, 
--może to być przydatne na stronach internetowych, skryptach 
SELECT ST_AsTiff(ST_Union(rast)) 
FROM juras.porto_ndvi;

2.
--Podobnie do funkcji ST_AsTiff, ST_AsGDALRaster nie zapisuje danych wyjściowych bezpośrednio na dysku, 
--natomiast dane wyjściowe są reprezentacją binarną dowolnego formatu GDAL. 
SELECT ST_AsGDALRaster(ST_Union(rast), 'GTiff',ARRAY['COMPRESS=DEFLATE', 'PREDICTOR=2', 'PZLEVEL=9']) 
FROM juras.porto_ndvi; 

3.
--Funkcje ST_AsGDALRaster pozwalają nam zapisać raster w dowolnym formacie obsługiwanym przez gdal. 
--Aby wyświetlić listę formatów obsługiwanych przez bibliotekę uruchom: 
 SELECT ST_GDALDrivers(); 
 
 4.
 --Zapisywanie danych na dysku za pomocÄ… duĹĽego obiektu (large object, lo)
 CREATE TABLE tmp_out AS 
 SELECT lo_from_bytea(0, 
 ST_AsGDALRaster(ST_Union(rast), 'GTiff',  ARRAY['COMPRESS=DEFLATE', 'PREDICTOR=2', 'PZLEVEL=9']) 
 ) AS loid 
 FROM juras.porto_ndvi; ---------------------------------------------- 
 SELECT lo_export(loid, 'D:\Documents\Aleksandra_Juras\Studia_sem_5\Bazy_danych_przestrzennych\danecw6\save_tiff\myraster.tiff') --> Save the file in a place where the user postgres have access. In windows a flash drive usualy works fine. 
   FROM tmp_out; 
 ---------------------------------------------- 
 SELECT lo_unlink(loid) FROM tmp_out; --> Delete the large object. 
 
 
 -------geoserver-----------------------------
 CREATE TABLE public.mosaic (
    name character varying(254) COLLATE pg_catalog."default" NOT NULL,
    tiletable character varying(254) COLLATE pg_catalog."default" NOT NULL,
    minx double precision,
    miny double precision,
    maxx double precision,
    maxy double precision,
    resx double precision,
    resy double precision,
    CONSTRAINT mosaic_pkey PRIMARY KEY (name, tiletable)
);

insert into mosaic (name,tiletable) values ('mosaicpgraster','rasters.dem');



